<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.1">
<title>Chang HoHuan - Project Portfolio</title>
<link rel="stylesheet" href="../stylesheets/gh-pages.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<link rel="stylesheet" href="../stylesheets/coderay-asciidoctor.css">
</head>
<body class="article">
<div id="header">
<h1>Chang HoHuan - Project Portfolio</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="project-smart-insurance-collection"><a class="link" href="#project-smart-insurance-collection">PROJECT: Smart Insurance Collection</a></h2>
<div class="sectionbody">
<hr>
</div>
</div>
<div class="sect1">
<h2 id="overview"><a class="link" href="#overview">Overview</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Smart Insurance Collection(SIC) is for insurance agents who <strong>prefer to use a desktop app for managing contacts and appointments</strong>. More importantly, SIC is <strong>optimized for those who prefer to work with a Command Line Interface</strong> (CLI) while still having the benefits of a Graphical User Interface (GUI).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="summary-of-contributions"><a class="link" href="#summary-of-contributions">Summary of contributions</a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><strong>Major enhancement</strong>: added <strong>Predict Command</strong></p>
<div class="ulist">
<ul>
<li>
<p>What it does: It predicts the potential spending of a new customer based on the information from the
existing customers</p>
</li>
<li>
<p>Justification: A insurance agents can have hundreds of potential customers. It would be very handy and essential for
them to have a heuristics to rank the customers by priority. One obvious factor is how much the customer would spend on
the insurance. Based on this, a "predict" command would be very useful to predict how much a potential customers
will spend. Therefore the insurance agents can prioritise visiting those customers who are likely to spend more.</p>
</li>
<li>
<p>Highlights: This features requires a lot of foundational enhancements from other parts of the application. The original
Smart Insurance Collection does not come with the features to encode the information needed for the calculation. Hence I need to
add in more features in order to develop this feature. In the process, I have made enhancements to every components from
storage to the UI.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Minor enhancement</strong>: Income field, actual spending field and expected spending field.</p>
</li>
<li>
<p><strong>Code contributed</strong>: [<a href="https://github.com/CS2103JAN2018-T15-B2/main/blob/master/collated/functional/SoilChang.md" class="bare">https://github.com/CS2103JAN2018-T15-B2/main/blob/master/collated/functional/SoilChang.md</a>] [<a href="https://github.com/CS2103JAN2018-T15-B2/main/blob/master/collated/test/SoilChang.md" class="bare">https://github.com/CS2103JAN2018-T15-B2/main/blob/master/collated/test/SoilChang.md</a>]}_</p>
</li>
<li>
<p><strong>Other contributions</strong>:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Created and Integrated Travis into the repository</p>
</li>
<li>
<p>Created and released production builds in version 1.4 and 1.5</p>
</li>
<li>
<p>Created and Managed the main and side branches in the repository to manage the team project</p>
</li>
<li>
<p>Created the team organisation and instantiated the organisation repository</p>
</li>
<li>
<p>Helped and advised teammates on technical challenges in the whatsapp channel</p>
</li>
<li>
<p>Managed and safeguard the main release branch to ensure everyone has a working build</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-the-user-guide"><a class="link" href="#contributions-to-the-user-guide">Contributions to the User Guide</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Given below are sections I contributed to the User Guide. They showcase my ability to write documentation targeting end-users.</em></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="predict-code-predict-code"><a class="link" href="#predict-code-predict-code">Predict: <code>predict</code></a></h3>
<div class="paragraph">
<p>Predict the potential spending of the of a new customer. Some of the customers have
their "actual spending" recorded down while some don&#8217;t have because they have
not spent anything yet on the insurance policy. Hence this command is to
predict how much they will spend based on the information from the existing customers</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Initially</code><br>
two customers with <code>actualSpending</code> &gt; 0 while the other with
<code>actualSpending</code> == 0(actual spending will actually not be shown
if it is zero).</p>
</li>
<li>
<p><code>After</code><br>
The customer with <code>actualSpending</code> == 0 now has <code>expectedSpending</code> shown.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other Specification:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The solution is persistent. Hence when new users are added and old users are deleted,
the new solutions are calculated incrementally from the old solution.</p>
</li>
<li>
<p>When adding an new <code>Person</code>, the <code>/as</code>(Actual Spending) is optional.
if the actual spending is specified, the person is considered as existing
customer. Otherwise potential customer. The prediction is to predict
the potential customer&#8217;s spending based on the information on the
existing customers.</p>
</li>
<li>
<p>The solution is calculated through numerical methods. And numerical methods,
unlike Jesus, can&#8217;t solve everything. There are certain inputs that will lead
to divergent solution. Also, certain value might be too large to be captured
even with double. Hence in situations like this, an message of "Divergent solution"
would be presented with no prediction.</p>
</li>
<li>
<p>Like "help" command, the design is fault-tolerant. If you type extra text such
as <code>predict abcde</code> or <code>predict nothing please</code>, those are not valid command since
<code>predict</code> takes no other argument. But they will still be accepted as <code>predict</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Test input:<br>
    1. <code>add n/John One p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/30000 as/1500 age/20</code><br>
    2. <code>add n/John Two p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/15000 as/750 age/20</code><br>
    3. <code>add n/John Three p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/10000  age/20</code><br>
    4. <code>predict</code><br></p>
</div>
<div class="literalblock">
<div class="content">
<pre>==&gt;  John Three now shows expected spending of 500</pre>
</div>
</div>
<div class="paragraph">
<p>Test Input 2:<br>
    0. <code>clear</code><br>
    1. <code>add n/John One p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/30000 as/1000 age/20</code><br>
    2. <code>add n/John Two  p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/9000 as/300 age/20</code><br>
    3. <code>add n/John Three p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/20000  age/20</code><br>
    4. <code>predict</code><br></p>
</div>
<div class="literalblock">
<div class="content">
<pre>==&gt;  John Three should have 666.67 expected spending</pre>
</div>
</div>
<div class="paragraph">
<p>Test Input 3:<br>
    0. <code>clear</code><br>
    1. <code>add n/John One p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/12345678000 as/150 age/20</code><br>
    2. <code>add n/John Two  p/98765432 e/johnd@example.com a/311, Clementi Ave 2, #02-25 t/friends t/owesMoney i/15000 as/750 age/20</code><br>
    3. <code>predict</code></p>
</div>
<div class="literalblock">
<div class="content">
<pre>==&gt;  divergent solution</pre>
</div>
</div>
<div class="paragraph">
<p>this is to illustrate unrealistic extreme values might lead to divergent solution.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="contributions-to-the-developer-guide"><a class="link" href="#contributions-to-the-developer-guide">Contributions to the Developer Guide</a></h2>
<div class="sectionbody">
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 100%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project.</em></p></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="prediction-function"><a class="link" href="#prediction-function">Prediction Function</a></h3>
<div class="paragraph">
<p>A command by the keyword of "predict" is added. It takes no argument.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Overview</code> : Customers in the list may or may not have
"actual spending" entered. Because at the point,
the customer may not have purchased any policy at all. Those
customers without actual spending would be those customers who
have not spent anything. Predict function would use gradient descent
method to reach the least square regression line. And the value produced
by the least square regression line would be used as the prediction value.</p>
</li>
<li>
<p><code>Implementation</code> :</p>
<div class="ulist">
<ul>
<li>
<p>The <code>GradientDescent</code> is designed to be a singleton class. The reason for that is
the weights from the previous calculation should be retained and used for the subsequent
calculation. Therefore only one instantiation of this class is allowed.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> GradientDescent(PredictionModel model) {
        <span class="local-variable">this</span>.model = model;
    }

    <span class="directive">public</span> <span class="directive">static</span> GradientDescent getInstance(PredictionModel model) {
        <span class="keyword">if</span> (instance == <span class="predefined-constant">null</span>) {
            instance = <span class="keyword">new</span> GradientDescent(model);
            instance.resetWeights();
        }
        <span class="keyword">return</span> instance;
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor takes a <code>PredictionModel</code>.</p>
</div>
<div class="paragraph">
<p>PredictionModel is a interface that extends Model interface. The reason for this implementation is
that <code>GradientDescent</code> requires some specific methods from the <code>Model</code> interface. And those methods are
not useful to any other part of the app. Hence a new interface is created for <code>ModelManager</code> to implement
specifically for gradient descent purpose. This to ensure the proper separation of concern and encapsulation.
Those components that does not interact with predict command will not need to know the existence of those
methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">PredictionModel</span> <span class="directive">extends</span> Model {
    <span class="type">void</span> preparePredictionData(<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt;&gt; matrix, <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; targets,
                               <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; normalizationConstant);

    <span class="type">void</span> updatePredictionResult(<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; weights)
            <span class="directive">throws</span> CommandException;
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>GradientDescent</code> class is a simply a solver. The driver class is a public method called <code>solve()</code>.
It does not take any arguments. All the parameters required to run the solver is generated automatically
within the class.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> CommandResult solve() <span class="directive">throws</span> CommandException {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solver consists of 5 Steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instantiation</p>
</li>
<li>
<p>Data Preparation</p>
</li>
<li>
<p>Solving</p>
</li>
<li>
<p>Validating</p>
</li>
<li>
<p>Update Results</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>Instantiation</code>:<br></p>
</div>
<div class="paragraph">
<p>The solver basically follows the equation of Aw=x, where
A is a matrix, w is the weights and x is the target output.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt;&gt; matrix = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;(<span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;());
<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; targets = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Data Preparation</code>:<br></p>
</div>
<div class="paragraph">
<p>A method from <code>PredictionModel</code> interface is invoked to to extract the relevant values from the
<code>ModelManager</code> to the function. This implementation is to ensure proper encapsulation. <code>GradientDescent</code>
does not need to know what data is available or what formats are those data stored in the
<code>ModelManager</code>. It only needs to know a consistent matrix A and vector x are passed back.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="local-variable">this</span>.model.preparePredictionData(matrix, targets, normalizationConstant);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Solving</code>:<br></p>
</div>
<div class="paragraph">
<p>A function call to descent().</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">descent(matrix, targets);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of descent():
The idea is simply looping through each epoch and calculate the outcome and error. use their difference
and learning rate to generate an update for the weights.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="type">void</span> descent(<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt;&gt; matrix, <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; targets) {
    <span class="keyword">for</span> (<span class="type">int</span> itt = <span class="integer">0</span>; itt &lt; epoch; itt++) {

        <span class="comment">//check data validity</span>
        <span class="keyword">if</span> (<span class="local-variable">this</span>.hasNaN(<span class="local-variable">this</span>.weights)) {
            <span class="local-variable">this</span>.logger.warning(<span class="string"><span class="delimiter">&quot;</span><span class="content">The solution is not convergent</span><span class="delimiter">&quot;</span></span>);
            <span class="keyword">break</span>;
        }

        <span class="comment">// fixed amount of training iteration</span>
        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="integer">0</span>; r &lt; matrix.size(); r++) { <span class="comment">//going through each training data</span>

            <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; row = matrix.get(r);
            <span class="predefined-type">Double</span> outcome = predict(row);
            <span class="predefined-type">Double</span> error = targets.get(r) - outcome;
            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; row.size(); i++) {
                <span class="predefined-type">Double</span> deltaW = <span class="local-variable">this</span>.learningRate * error * row.get(i);
                <span class="local-variable">this</span>.weights.set(i, <span class="local-variable">this</span>.weights.get(i) + deltaW);
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Validating</code>:<br>
Here a simple method is used to validate the accuracy of the results. After the weights are
obtained, we validate it against the existing data. See how far off they are as compared to
the existing data. By right the training set and validation set should be separated. But since
for the current use case, the data entries are usually very little. Hence this simplified method
is used instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="predefined-type">Double</span> validate(<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt;&gt; matrix, <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">Double</span>&gt; targets) {
    <span class="predefined-type">Double</span> average = <span class="float">0.0</span>;
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; matrix.size(); i++) {

        <span class="comment">//loop through each row</span>

        <span class="predefined-type">Double</span> outcome = <span class="local-variable">this</span>.predict(matrix.get(i));
        <span class="predefined-type">Double</span> error = <span class="predefined-type">Math</span>.abs((outcome - targets.get(i)) / targets.get(i));
        average += (<span class="integer">1</span> - error);
    }

    <span class="predefined-type">Double</span> confidence = average / targets.size() * <span class="integer">100</span>;
    <span class="keyword">if</span> (confidence &lt; <span class="integer">0</span>) {
        confidence = <span class="float">0.0</span>;
    } <span class="keyword">else</span> <span class="keyword">if</span> (confidence &gt; <span class="integer">100</span>) {
        confidence = <span class="float">100.0</span>;
    }
    <span class="keyword">return</span> confidence;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Update Results</code>:<br>
The implementation of updating follows closed to that of Edit command. The actual updating
takes place in the model itself instead of <code>GradientDescent</code> class. Again, <code>GradientDescent</code>
does not need to be concerned with how the model is updated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">try</span> {
    <span class="local-variable">this</span>.model.updatePredictionResult(<span class="local-variable">this</span>.getWeights());
    <span class="keyword">return</span> <span class="keyword">new</span> CommandResult(<span class="predefined-type">String</span>.format(MESSAGE_PREDICTION_SUCCESS)
            + <span class="string"><span class="delimiter">&quot;</span><span class="content">, with Confidence Rate </span><span class="delimiter">&quot;</span></span>
            + <span class="predefined-type">String</span>.format(<span class="string"><span class="delimiter">&quot;</span><span class="content">%.2f</span><span class="delimiter">&quot;</span></span>, confidence)
            + <span class="string"><span class="delimiter">&quot;</span><span class="content">%</span><span class="delimiter">&quot;</span></span>
    );
} <span class="keyword">catch</span> (CommandException e) {
    <span class="keyword">return</span> <span class="keyword">new</span> CommandResult(<span class="predefined-type">String</span>.format(MESSAGE_PREDICTION_FAIL));
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Future Work</code>:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The regression line is currently 2 dimensional at the moment, with only
the contribution from "actual spending" and "income". In the future, the parameters
should be extended to multi-dimension with other fields included.</p>
</li>
<li>
<p>Auto separate training set and validation set once data gets large enough.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../images/ModelClassDiagramUpdated.png" alt="ModelClassDiagramUpdated" width="800">
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2018-04-15 13:19:36 UTC
</div>
</div>
</body>
</html>